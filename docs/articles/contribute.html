<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Best practices to contribute • rasterTools</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/lumen/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Best practices to contribute">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">rasterTools</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">0.6.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Vignettes
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/introduction.html">Intro and Examples</a>
    </li>
    <li>
      <a href="../articles/landscape_metrics.html">Landscape metrics</a>
    </li>
    <li>
      <a href="../articles/contribute.html">Best practices to contribute</a>
    </li>
  </ul>
</li>
<li>
  <a href="../reference/index.html">
    <span class="fa fa-file-code-o"></span>
     
    Glossary
  </a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="../articles/usecases.html">
    <span class="far fa far fa-list-alt"></span>
     
    Use cases
  </a>
</li>
<li>
  <a href="../news/index.html">
    <span class="fa fa-newspaper-o"></span>
     
    News
  </a>
</li>
<li>
  <a href="https://github.com/EhrmannS/rastertools">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Best practices to contribute</h1>
                        <h4 class="author">Steffen Ehrmann</h4>
            
            <h4 class="date">2018-07-31</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/EhrmannS/rasterTools/blob/master/vignettes/contribute.Rmd"><code>vignettes/contribute.Rmd</code></a></small>
      <div class="hidden name"><code>contribute.Rmd</code></div>

    </div>

    
    
<p>In this document you can find an outline of the default design of the operators employed in the core-functions of <code>rasterTools</code> and other “best practices”. In case you want to write a new operator that is readily compatible with <code>rasterTools</code>, it is recommended that you stick to the design which is suggested here. I do my best to keep this document updated, but as the development of <code>rasterTools</code> and other packages progresses, one or the other thing here may be outdate, so don’t be too frustrated if something does not work ad-hoc. If you want the operator you wrote to be part of <code>rasterTools</code>, create a pull-request and when everything is running smoothly, I will include you as author of that function, if you want that.</p>
<p>Many of the code-chunks of this documentation are written in so-called pseudocode, which is a placeholder or variable, which would be replaced in an actual function. Pseudocode elements are written in CAPITAL LETTERS and typically have a rather self-explanatory name.</p>
<p><code>rasterTools</code> builds largely on the framework of the <a href="https://cran.r-project.org/web/packages/checkmate/index.html"><code>checkmate</code></a> package so that arguments are properly tested. This makes the source code very verbose but helps to maintain consistency.</p>
<div id="generate-spatial-patterns" class="section level1">
<h1 class="hasAnchor">
<a href="#generate-spatial-patterns" class="anchor"></a>Generate spatial patterns</h1>
<p><em>Coming soon</em></p>
</div>
<div id="obtain-spatial-datasets" class="section level1">
<h1 class="hasAnchor">
<a href="#obtain-spatial-datasets" class="anchor"></a>Obtain spatial datasets</h1>
<div id="tldr" class="section level2">
<h2 class="hasAnchor">
<a href="#tldr" class="anchor"></a><em>tl;dr</em>
</h2>
<ul>
<li>use <code>checkmate</code>
</li>
<li>take proper care of the projection, <code>mask</code> provides the target projection, after loading and cropping the data reproject to this projection.</li>
<li>use <code><a href="../reference/geomTiles.html">geomTiles()</a></code> in case the dataset is tiled.</li>
<li>make use of the <code><a href="../reference/loadData.html">loadData()</a></code> function.</li>
<li>most likely you need to write a small <code>downloadMYDATASET()</code> function, see below.</li>
<li>assign a nice colourtable and brief history to the resulting <code>raster</code> object.</li>
</ul>
</div>
<div id="check-arguments" class="section level2">
<h2 class="hasAnchor">
<a href="#check-arguments" class="anchor"></a>Check arguments</h2>
<p>Each operator for the <code><a href="../reference/obtain.html">obtain()</a></code>-function has at least the argument <code>mask</code> but most likely also other arguments to handle distinct subsets of the dataset, such as different years or products. We must first make sure that the arguments follow the intended input patterns. <code>rasterTools</code> accepts <code>geom</code> objects as spatial objects, so we need to test which spatial mask we deal with.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">oDATASET &lt;-<span class="st"> </span><span class="cf">function</span>(mask, ARG){
  
  existsGeom &lt;-<span class="st"> </span><span class="kw">testClass</span>(mask, <span class="dt">classes =</span> <span class="st">"geom"</span>)
  existsSpatial &lt;-<span class="st"> </span><span class="kw">assert</span>(<span class="kw">testClass</span>(mask, <span class="dt">classes =</span> <span class="st">"SpatialPolygon"</span>),
                          <span class="kw">testClass</span>(mask, <span class="dt">classes =</span> <span class="st">"SpatialPolygonsDataFrame"</span>))
  <span class="co"># existsSF &lt;- testClass(mask, classes = "...") for a "simple features" object</span>
  <span class="cf">if</span>(<span class="op">!</span>existsGeom <span class="op">&amp;</span><span class="st"> </span><span class="op">!</span>existsSpatial){
    <span class="kw">stop</span>(<span class="st">"please provide either a SpatialPolygon* or a geom to mask with."</span>)
  }
  <span class="kw">assertXZY</span>(ARG)
  <span class="co"># assertTRUE(all(years %in% c(1990, 2000, 2006, 2012)))</span></code></pre></div>
<p>The arguments would typically reflect characteristics of the dataset, which could be seen as the distinctive for the subsets of this dataset. This is, for instance, the ‘year’ in case of the Corine land-cover dataset, which provides a distinct map for each of the years 1990, 2000, 2006 and 2012, or the ‘product’ and ‘layer’ in case of a MODIS dataset. You can define as many of these arguments as needed.</p>
</div>
<div id="handle-projection" class="section level2">
<h2 class="hasAnchor">
<a href="#handle-projection" class="anchor"></a>Handle projection</h2>
<p>We must handle the projection of the involved files, to avoid accidently building on spatial objects with the wrong coordinate reference system. Controlling the projection is crucial, as problems with the projection of one out of many files may already lead to problems that are hard to trace back. <code>rasterTools</code> comes with various functions that are able to handle more than one class, socalled generic functions and class specific methods. One pair of such functions is <code><a href="../reference/getCRS.html">getCRS()</a></code> and <code><a href="../reference/setCRS.html">setCRS()</a></code>, which can handle both <code>Spatial*</code> and <code>geom</code> objects (and in the future also <code>sf</code>). This means that we can use simple code statements and can avoid the “diverse beauty” of the various spatial packages that are recently out there.</p>
<p>The object defined in <code>mask</code> provides the target projection the user wants to work with, so we take the <code>target_crs</code> from this mask. However, the mask has to be set to the same projection as the dataset we want to handle in our function, in this case the Lambert Azimuthal Equal-Area Projection. <code>rasterTools</code> includes the dataset <code>projs</code> in which some of the most frequent projections are stored, but you can of course use any other <a href="http://proj4.org/">proj4</a> string.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  target_crs &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getCRS.html">getCRS</a></span>(<span class="dt">x =</span> mask)
  <span class="cf">if</span>(target_crs <span class="op">!=</span><span class="st"> </span>projs<span class="op">$</span>laea){
    mask &lt;-<span class="st"> </span><span class="kw"><a href="../reference/setCRS.html">setCRS</a></span>(<span class="dt">x =</span> mask, <span class="dt">crs =</span> projs<span class="op">$</span>laea)
  }
  theExtent &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getExtent.html">getExtent</a></span>(<span class="dt">x =</span> mask)</code></pre></div>
<p>In case the mask is not of class <code>geom</code>, we want to create this class:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="cf">if</span>(existsSpatial){
    mask &lt;-<span class="st"> </span><span class="kw"><a href="../reference/gFrom.html">gFrom</a></span>(<span class="dt">input =</span> mask)
  }</code></pre></div>
</div>
<div id="determine-target-tiles" class="section level2">
<h2 class="hasAnchor">
<a href="#determine-target-tiles" class="anchor"></a>Determine target tiles</h2>
<p>Tiles are a set of regularly arranged neighbouring rectangles that represent different “windows” by which a large spatial dataset is subdivided. This approach is being chosen by many of the providers of gridded dataset to make files available in small enough chunks that can easier be handled. <code>rasterTools</code> comes with the function <code><a href="../reference/geomTiles.html">geomTiles()</a></code> that lets you outline tiles with the specific intention that these tiles represent the tiling of the gridded datasets. We first outline the overall extent of the tiles, i.e. their minimum and maximum values in x and y dimension. Then we specify the number of cells/rectangles and the projection:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  aWindow &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="op">-</span><span class="dv">180</span>, <span class="dv">180</span>),
                        <span class="dt">y =</span> <span class="kw">c</span>(<span class="op">-</span><span class="dv">60</span>, <span class="dv">80</span>))
  datasetTiles &lt;-<span class="st"> </span><span class="kw"><a href="../reference/geomTiles.html">geomTiles</a></span>(<span class="dt">window =</span> aWindow, <span class="dt">cells =</span> <span class="kw">c</span>(<span class="dv">36</span>, <span class="dv">14</span>), <span class="dt">crs =</span> projs<span class="op">$</span>longlat)</code></pre></div>
<p>From the object <code>myTiles</code> we need to determine the subset of rectangles in which the data we are interested in are to be found (this is not ideally solved at the moment and might change in the future):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  tabTiles &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getTable.html">getTable</a></span>(<span class="dt">x =</span> datasetTiles)
  tabMask &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getTable.html">getTable</a></span>(<span class="dt">x =</span> mask)
  ids &lt;-<span class="st"> </span><span class="kw">unique</span>(tabTiles<span class="op">$</span>id)
  xMatch &lt;-<span class="st"> </span>yMatch &lt;-<span class="st"> </span><span class="ot">NULL</span>
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="kw">seq_along</span>(ids)){
    temp &lt;-<span class="st"> </span>tabTiles[tabTiles<span class="op">$</span>id <span class="op">==</span><span class="st"> </span>ids[i],]
    xMatch &lt;-<span class="st"> </span><span class="kw">c</span>(xMatch, <span class="kw">ifelse</span>(<span class="kw">any</span>(tabMask<span class="op">$</span>x <span class="op">&lt;</span><span class="st"> </span><span class="kw">max</span>(temp<span class="op">$</span>x)) <span class="op">&amp;</span><span class="st"> </span><span class="kw">any</span>(tabMask<span class="op">$</span>x <span class="op">&gt;</span><span class="st"> </span><span class="kw">min</span>(temp<span class="op">$</span>x)), <span class="ot">TRUE</span>, <span class="ot">FALSE</span>))
    yMatch &lt;-<span class="st"> </span><span class="kw">c</span>(yMatch, <span class="kw">ifelse</span>(<span class="kw">any</span>(tabMask<span class="op">$</span>y <span class="op">&lt;</span><span class="st"> </span><span class="kw">max</span>(temp<span class="op">$</span>y)) <span class="op">&amp;</span><span class="st"> </span><span class="kw">any</span>(tabMask<span class="op">$</span>y <span class="op">&gt;</span><span class="st"> </span><span class="kw">min</span>(temp<span class="op">$</span>y)), <span class="ot">TRUE</span>, <span class="ot">FALSE</span>))
  }
  tiles &lt;-<span class="st"> </span>xMatch <span class="op">&amp;</span><span class="st"> </span>yMatch
  myTiles &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getSubset.html">getSubset</a></span>(tiles_gfc, tabTiles<span class="op">$</span>id <span class="op">==</span><span class="st"> </span>ids[tiles])</code></pre></div>
</div>
<div id="iterate-through-the-arguments" class="section level2">
<h2 class="hasAnchor">
<a href="#iterate-through-the-arguments" class="anchor"></a>Iterate through the arguments</h2>
<p>Once we have determined the spatial subset of the data we are interested in, we have to find the other subsets, maybe according to the temporal extent or according to other properties of the dataset. When a dataset is stored in a tiled way, we have to figure out code that would let us derive the name under which the tile of our interest is stored. To assist in this, we could for instance create an <code>id</code> variable for the object <code>datasetTiles</code>, that contains the systematic names, or components thereof. Other name components could perhaps be derived from the respective arguments based on which we want to subset. The <code><a href="../reference/oGFC.html">oGFC()</a></code> functions handles this in the following way:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  tabTiles &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getTable.html">getTable</a></span>(<span class="dt">x =</span> myTiles)
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">unique</span>(tabTiles<span class="op">$</span>id)){
    min_x &lt;-<span class="st"> </span><span class="kw">min</span>(tabTiles<span class="op">$</span>x[tabTiles<span class="op">$</span>id <span class="op">==</span><span class="st"> </span>i])
    max_y &lt;-<span class="st"> </span><span class="kw">max</span>(tabTiles<span class="op">$</span>y[tabTiles<span class="op">$</span>id <span class="op">==</span><span class="st"> </span>i])
  
    <span class="cf">if</span>(min_x <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span>){
      easting &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="kw">sprintf</span>(<span class="st">'%03i'</span>, <span class="kw">abs</span>(min_x)), <span class="st">'W'</span>)
    } <span class="cf">else</span>{
      easting &lt;-<span class="st">  </span><span class="kw">paste0</span>(<span class="kw">sprintf</span>(<span class="st">'%03i'</span>, min_x), <span class="st">'E'</span>)
    }
    <span class="cf">if</span>(max_y <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span>){
      northing &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="kw">sprintf</span>(<span class="st">'%02i'</span>, <span class="kw">abs</span>(max_y)), <span class="st">'S'</span>)
    } <span class="cf">else</span>{
      northing &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="kw">sprintf</span>(<span class="st">'%02i'</span>, max_y), <span class="st">'N'</span>)
    }
    gridId &lt;-<span class="st"> </span><span class="kw">paste0</span>(northing, <span class="st">'_'</span>, easting)
    fileNames &lt;-<span class="st">  </span><span class="kw">paste0</span>(<span class="st">"Hansen_GFC2015_"</span>, layerNames, <span class="st">"_"</span>, gridId, <span class="st">'.tif'</span>)
  
    <span class="cf">for</span>(j <span class="cf">in</span> <span class="kw">seq_along</span>(ARG)){
      <span class="co"># ---&gt; Load and crop here &lt;---</span>
    }
  }</code></pre></div>
</div>
<div id="load-and-crop-raster" class="section level2">
<h2 class="hasAnchor">
<a href="#load-and-crop-raster" class="anchor"></a>Load and crop raster</h2>
<p>As some of the spatial operations may take up a large quantity of time, <code>rasterTools</code> is designed so that it always gives feedback about what it is doing at the moment. For that purpose the <code>message()</code> function is employed throughout in combination with <code>paste0()</code> (a slightly more efficient wrapper of <code>paste()</code> with <code>sep = ''</code> on default). The feedback should of course not overload the user but give informative feedback, so be brief and concise.</p>
<p>Feedback for an action should always come directly before the action is carried out. This assures that no other, maybe time-costly, operation interfers with it. <code>tDATASET</code> is the target object that would be processed successively to load the subset of dataset (<code>...</code>). Often a dataset may not be saved with a coordinate reference system and in these cases, this needs to be assigned. In most cases you will want to crop the overall dataset to <code>mask</code> or load only parts of it into <code>R</code>. The smaller the spatial objects, the faster computation involving them can be carried out. It is no problem to overwrite a object with a cropped version of itself, since the original object usually has no other purpose other than selecting a subset of it. Overwriting these potentially large spatial files is thus a memory friendly option of which you should take advantage.</p>
</div>
<div id="merge-multiple-tiles" class="section level2">
<h2 class="hasAnchor">
<a href="#merge-multiple-tiles" class="anchor"></a>Merge multiple tiles</h2>
</div>
<div id="reproject" class="section level2">
<h2 class="hasAnchor">
<a href="#reproject" class="anchor"></a>Reproject</h2>
<p>As a final step of operations on the spatial data you should reproject the output. If a user wants to include various different datasets in one analysis, all the datasets should have the same projection. <code>rasterTools</code> assumes that this is the projection the initial <code>mask</code> had. Hence, <code>tDATASET</code> should be reprojected to this crs.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">            <span class="cf">if</span>(<span class="kw">proj4string</span>(mask) <span class="op">!=</span><span class="st"> </span>target_crs){
              <span class="kw">cat</span>(<span class="kw">paste0</span>(<span class="st">"reprojecting tDATASET to '"</span>, <span class="kw">strsplit</span>(target_crs, <span class="st">" "</span>)[[<span class="dv">1</span>]][<span class="dv">1</span>], <span class="st">"'</span><span class="ch">\n</span><span class="st">"</span>))
              tDATASET &lt;-<span class="st"> </span><span class="kw">projectRaster</span>(tDATASET, <span class="dt">crs =</span> target_crs, ...)
            }</code></pre></div>
</div>
<div id="postprocessing" class="section level2">
<h2 class="hasAnchor">
<a href="#postprocessing" class="anchor"></a>Postprocessing</h2>
<p>Some datasets have a typical colour pattern which would be worth to maintain. <code>raster</code> objects have the slot <code>$colortable</code>, where we can store a set of colour values that shall be used to visualise the <code>raster</code>.</p>
</div>
</div>
<div id="modify-gridded-objects" class="section level1">
<h1 class="hasAnchor">
<a href="#modify-gridded-objects" class="anchor"></a>Modify gridded objects</h1>
<p>Each operator that modifies a raster has at least the argument <code>obj</code>, which denotes the raster that shall be modified. Most computations in <code>rasterTools</code> are performed on matrix objects and thus the first thing is to define a matrix from the raster. Often, also the values of this raster are of interest and in that case you would assign them to a variable early on.</p>
<pre><code>rMODIFY &lt;- function(obj, ARG){
  mat &lt;- as.matrix(obj)
  vals &lt;- values(obj)
  </code></pre>
<p>Next, a computation is carried out. In case the computation is based on a specifically formated raster, for example a binarised one, this should be tested and a respective error should be thrown. In most cases it is preferable to interrupt a computation that has not been strictly outlined over wasting time on deriving flawed results.</p>
<pre><code>  if(!isBinaryC(mat)){
    stop("spatial object is not binary, please run 'rBinarise()' initially.")
  }
  temp &lt;- ...</code></pre>
<p>As you have carried out the computations with a matrix, you have to transfer the matrix back to a <code>raster</code>. You would use the spatial information of <code>obj</code> to reconstruct the exact dimensions and coordinate reference system (CRS). In very rare cases the new raster’s dimensions have changed and in this case also the extent and CRS must be adapted computationally.</p>
<pre><code>  out &lt;- raster(temp)
  extent(out) &lt;- extent(obj)
  sp::proj4string(out) &lt;- sp::proj4string(obj)</code></pre>
<p>Each <code>raster</code> object has the slot <code>@history</code> and <code>rasterTools</code> takes advantage of that. This slot is recently not used by the raster package and hence you can fill it with information. <code>rasterTools</code> expects here a list of all the operations that have been carried out with the raster. So you would either specify here that the raster was just loaded from the memory, which is the default that needs to be assigned to any raster that has an unknown history (in the eyes of <code>rasterTools</code>, that is). Otherwise, extract the <code>@history</code> slot and concatenate an informative but concise sentence about what your algorithm has done to the raster.</p>
<p>The <code><a href="../reference/visualise.html">visualise()</a></code> function has been conceptualised so that it can print the history of a raster. This may be a rather helpful tool when putting together complex spatial operations or when reporting the procedure according to which a raster has been created. Moreover, to increase the awareness of the user with which raster one deals, you should also assign a <code>SHORT_NAME</code> to the raster. This will be printed as panel name by <code><a href="../reference/visualise.html">visualise()</a></code>.</p>
<pre><code>  if(length(obj@history)==0){
    history &lt;- list(paste0("object loaded from memory"))
  } else{
    history &lt;- obj@history
  }
  out@history &lt;- c(history, list(paste0("THIS HAS BEEN DONE")))

  names(out) &lt;- paste0("SHORT_NAME")
  </code></pre>
<p>Finally the raster would be returned.</p>
<pre><code>  return(out)
}</code></pre>
</div>
<div id="measure-gridded-objects" class="section level1">
<h1 class="hasAnchor">
<a href="#measure-gridded-objects" class="anchor"></a>Measure gridded objects</h1>
<p>All the generic metrics already come with <code>rasterTools</code> so there is no need to contribute, other than suggesting bug fixes or requesting new features.</p>
<p>That being said, derived metrics are deliberately constructed so that everybody can easiy contribute and write their own “function”. In that case, however, mathematical functions. A derived landscape metric in <code>rasterTools</code> is nothing more than the mathematical equation that relates several properties of the raster, which are measured by generic metrics (terms). Hence, one simply has to define the terms and outline the equation that shall be used to compute the metric.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">list</span>(<span class="dt">term1 =</span> <span class="kw">list</span>(<span class="dt">operator =</span> <span class="st">"mArea"</span>, <span class="dt">scale =</span> <span class="st">"patch"</span>),
     <span class="dt">term2 =</span> <span class="kw">list</span>(<span class="dt">operator =</span> <span class="st">"mArea"</span>, <span class="dt">scale =</span> <span class="st">"window"</span>),
     <span class="dt">newMetric =</span> <span class="st">"term1 / term2 * 100"</span>)</code></pre></div>
<p>If you want to contribute to the collection of derived metrics listed in the <a href="articles/landscape_metrics.html">landscape metrics</a> vignette, simply edit that file and create a pull request, or let the author of <code>rasterTools</code> know about your addition via E-Mail.</p>
</div>
<div id="loading-spatial-data-into-r" class="section level1">
<h1 class="hasAnchor">
<a href="#loading-spatial-data-into-r" class="anchor"></a>Loading spatial data into R</h1>
<p>Also <code><a href="../reference/loadData.html">loadData()</a></code> is designed in a modular way to provide flexibility, in case other dataset formats should become important in the (near) future. The function is designed so that it determines the files that should be loaded, based on what is specified in its arguments. The function <code><a href="../reference/loadData.html">loadData()</a></code> contains all the logic that is needed to handle a file without having to determine the actual format. All the logic that depends on the structure of files with that format or other requirements that come with the format is then outsourced to the respective <code>load*</code> and <code>download*</code> functions. These classes can, however, be very slim wrappers around the actual function that loads the format. In the end this means that virtually any file format that can be loaded into <code>R</code> can be handled by <code><a href="../reference/loadData.html">loadData()</a></code>, given the respective wrapper has been defined.</p>
<div id="load" class="section level2">
<h2 class="hasAnchor">
<a href="#load" class="anchor"></a><code>load*</code>
</h2>
<p>Each class should be able to take an argument <code>path</code>, the exact location of the file to load. Optionally, for instance when the file is saved in <code>shp</code>, the argument <code>layer</code>, declaring the layer to be loaded.</p>
<p>One of the simplest classes for <code><a href="../reference/loadData.html">loadData()</a></code> is that for loading shape-files:</p>
<pre><code>loadSHP &lt;- function(path, layer){
  rgdal::readOGR(dsn = path,
                 layer = layer,
                 verbose = FALSE)
}</code></pre>
<p>The simplest ‘template’ of this class would hence be:</p>
<pre><code>loadFORMAT &lt;- function(path, layer){
  rgdal::readOGR(dsn = path,
                 layer = layer,
                 verbose = FALSE)
}</code></pre>
<p>Building on <code><a href="http://www.rdocumentation.org/packages/rgdal/topics/readOGR">rgdal::readOGR()</a></code> makes defining new classes for <code><a href="../reference/loadData.html">loadData()</a></code> a breeze. But you can of course also use other functions, if they should be more efficient, or if <code>readOGR()</code> doesn’t support the format.</p>
<p>It is important to note, that neither the classes to <code><a href="../reference/loadData.html">loadData()</a></code> nor <code><a href="../reference/loadData.html">loadData()</a></code> handle the coordinate reference system, this is carried out by <code>spCRS()</code>. The class simply loads what is found in <code>path</code> with <code>layer</code> and makes it available to <code><a href="../reference/loadData.html">loadData()</a></code>, which turns the information into the respective output format.</p>
</div>
<div id="download" class="section level2">
<h2 class="hasAnchor">
<a href="#download" class="anchor"></a><code>download*</code>
</h2>
</div>
</div>
<div id="be-informative" class="section level1">
<h1 class="hasAnchor">
<a href="#be-informative" class="anchor"></a>Be informative</h1>
<p><code>rasterTools</code> intends to be as transparent as possible and this ensues that error messages or relevant warnings are easy to understand and appear whenever a problem occurs. This is where the checkmate package comes in, that <code>rasterTools</code> heavily utilizes. Thus many of the recommendations with regard to error management derive from their directives. Also, since several of the functions here can be quite time-consuming, a message that informs the user about the currently processing step can be helpful. This includes a progressbar, which indicates the progress of a iterative computation.</p>
<p>For example, the <code>index()</code> function builds an index based on all the files that are found in a certain directory. This index can be useful when a project is meant to deal with a large number of files in some directory (for instance in “./myProject/aLargeNumberOfFiles/”) that need to be accessed arbitrarily, i.e. not all of them at a time or only a subset according to the current conditions. Hence, it might not be required to load all the files into the global environment of R but instead it would be useful to provide a simple key, according to which the files can be loaded. Think, for example, about all the different products, tiles, temporal extents and layers of the MODIS dataset. The file-names of the respective files are a long and cumbersome combination of all these information and very timeconsuming to type in; sure, tab-completion is your friend, but with these files you still need tab through several “levels” of file specification, so to speak.</p>
<p>Anyway, while <code>index()</code> is an example of functions that makes <code>rasterTools</code> more informative, it utilizes the <code>txtProgressBar</code> function in the following way:</p>
<pre><code>FILES &lt;- list.files(PATH)
pb &lt;- txtProgressBar(min = 0, max = length(FILES), style = 3, char="&gt;", width=getOption("width")-14)
for(i in seq_along(FILES)){

  # store the name and an abbreviation of each file to a data-frame
  setTxtProgressBar(pb, i)
  
}
close(pb)</code></pre>
<p>This informs the user about the progress of this function and should be helpful especially when many files need to be accessed and the whole procedure naturally takes a while. If your new function also goes through many files, it would be recommended that you employ the same specifications for the progress bar you may want to use.</p>
<p>Moreover, if computations are employed that take a certain while, for instance loading a large raster into the global environment, or reprojecting a raster, it may be useful to inform the user also about these steps. This is frequently done in the <code><a href="../reference/obtain.html">obtain()</a></code> operators. Here, the <code>message</code> function is used. This function has the advantage over <code>cat</code>, that it can be integrated with a translation framework that would provide the messages in the language <code>rasterTools</code> is expected to communicate with the user (not supported yet). Hence, it is recommended that you also use this function, so that your function seamlessly blends in with this framework.</p>
</div>
<div id="create-a-bibliography-entry" class="section level1">
<h1 class="hasAnchor">
<a href="#create-a-bibliography-entry" class="anchor"></a>Create a bibliography entry</h1>
<p><code>rasterTools</code> has the <code><a href="../reference/reference.html">reference()</a></code> function, which helps the user to put together the correct bibliography when reporting the results in a publication. If your function is based on the work that has been defined by somebody else, it should report the respective reference. <code>R</code> comes with the <code>bibentry()</code> function, which lets you define the reference(s) of your function.</p>
<pre><code>bib &lt;- bibentry(bibtype = "",
              title = "",
              author = person(""),
              year = ,
              ... 
)</code></pre>
<p>Then, your function should first check whether a bibliography already exists in the options of the current session. If this is not found, create it. If a bibliography object has already been created, it needs to be checked whether or not the recent reference is already included and if this is not the case, concatenate the reference.</p>
<pre><code>if(is.null(getOption("bibliography"))){
  options(bibliography = bib)
} else{
  currentBib &lt;- getOption("bibliography")
  if(!bib%in%currentBib){
    options(bibliography = c(currentBib, bib))
  }
}</code></pre>
<p>This will assure that the algorithm your function is based upon is properly included when it is used in a computation that should be published.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#generate-spatial-patterns">Generate spatial patterns</a></li>
      <li>
<a href="#obtain-spatial-datasets">Obtain spatial datasets</a><ul class="nav nav-pills nav-stacked">
<li><a href="#tldr"><em>tl;dr</em></a></li>
      <li><a href="#check-arguments">Check arguments</a></li>
      <li><a href="#handle-projection">Handle projection</a></li>
      <li><a href="#determine-target-tiles">Determine target tiles</a></li>
      <li><a href="#iterate-through-the-arguments">Iterate through the arguments</a></li>
      <li><a href="#load-and-crop-raster">Load and crop raster</a></li>
      <li><a href="#merge-multiple-tiles">Merge multiple tiles</a></li>
      <li><a href="#reproject">Reproject</a></li>
      <li><a href="#postprocessing">Postprocessing</a></li>
      </ul>
</li>
      <li><a href="#modify-gridded-objects">Modify gridded objects</a></li>
      <li><a href="#measure-gridded-objects">Measure gridded objects</a></li>
      <li>
<a href="#loading-spatial-data-into-r">Loading spatial data into R</a><ul class="nav nav-pills nav-stacked">
<li><a href="#load"><code>load*</code></a></li>
      <li><a href="#download"><code>download*</code></a></li>
      </ul>
</li>
      <li><a href="#be-informative">Be informative</a></li>
      <li><a href="#create-a-bibliography-entry">Create a bibliography entry</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by <a href="https://orcid.org/0000-0002-2958-0796">Steffen Ehrmann</a>.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
