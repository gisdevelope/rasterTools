---
title: "Morphological operations"
author: "Steffen Ehrmann"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
  rmarkdown::html_document:
    toc: true
    toc_float: true
    theme: spacelab
link-citations: yes
vignette: >
  %\VignetteIndexEntry{Morphological operations}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(rasterTools)
library(raster)
library(magrittr)
continuous <- rtData$continuous
categorial <- rtData$categorial
catPatchesObj <- rSubstitute(obj = categorial, 
                             old = sort(base::unique(raster::values(categorial))),
                             new = c(1, 2, 3, 4, 3, 4, 5, 5, 5))
binarised <- rBinarise(categorial, match = c(41, 44, 47))
```

This document outlines basic operations that either stand on their own or may be necessary as basis for other operations. If you did not come from the page [Usecases](/rastertools/articles/usecases.html), you should go there now to read in the required objects.

# Morphologically open foreground
The morphological operation *open* is an erosion, followed by a dilation. It results in a raster where cells at the boundary of patches are removed if they are exposed. *Exposed* means here, that they are protruding to a degree that an erosion removes them so that a dilation isn't able to reconstruct them. The result depends on the chosen kernel, which must be the same in both operations.

```{r, fig.width=7, out.width='100%'}
opened <- rErode(binarised) %>% 
  rDilate()

visualise(opened)
```

# Morphologically close foreground
The morphological operation *close* is a dilation, followed by an erosion. It results in a raster where cells at the boundary of patches are added if this would lead to a closed patch. In this case, the dilation would add cells that an erosion could not remove because they are now "inside" a patch. The result depends also here on the chosen kernel, which again must be the same in both operations.

Instead of using the pipeline notation, we can construct an algorithm.

```{r, fig.width=7, out.width='100%'}
closePatches <- list(list(operator = "rDilate"),
                     list(operator = "rErode"))

closed <- modify(input = binarised, by = closePatches, sequential = TRUE)

visualise(closed, trace = TRUE)
```