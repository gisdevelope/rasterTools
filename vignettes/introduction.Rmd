---
title: "rasterTools"
author: "Steffen Ehrmann"
date: "`r Sys.Date()`"
bibliography: rasterTools.bib
output: 
  rmarkdown::html_vignette:
  rmarkdown::html_document:
    toc: true
    toc_float: true
    theme: spacelab
link-citations: yes
vignette: >
  %\VignetteIndexEntry{rasterTools}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

You might find `rasterTools` useful when your work depends in one way or the other on gridded earth observation data [@bush_connecting_2017]. This may be for simulating spatial patterns, building species distribution models or analysing and measuring spatial patterns/landscape features.

`rasterTools` does NOT intend to replace `raster` [@hijmans_raster_2017] but tries to present another workflow that is aimed at being more transparent and reproducible and easily accessible. Many of the typical steps in working with gridded data are summarised into *operators* (functions that carry out a specific spatial operation) and are grouped according to the type of work. In `rasterTools` the four functions `generate()`, `obtain()`, `modify()` and `measure()` represent the major tasks of spatial operations. `rasterTools` has been conceptualised so that these core functions are modular. Each of these functions manages all the code-logic that is common for the task at hand, e.g. to obtain gridded datasets. More specific code that manages, for instance, "loading the MODIS dataset" is oursourced to a seperate function (the `oMODIS()` operator). New operators to all the core functions and to `loadData()` can hence be devised easily.

Several operators are combined to *algorithms* to carry out (a sequence of) more complex spatial operations. An algorithm in `rasterTools` is given as list of lists.

    algo_name <- list(list(operator1,
                      list(operator2)))
                      
Operators are scope specific, i.e. they are typically only called in their respective core function. Each operator represents a `do.call()` compliant definition (type `?do.call` into the console to learn about it).

    do.call(what, args, quote = FALSE, envir = parent.frame())

Which translates to

    algo_name <- list(operator1 = list(what, args),
                      operator2 = list(what, args))

Its first element `what = operator_name` would outline the functions comprised in this algorithm (such as `"oMODIS"` or `"oCLC"`). Its second element can have any number of arguments required to put together the call (such as `product = "MOD17A3", layer = 2, period = c(2012, 2014)` or simply `period = 2006`).

    datasets <- list(list(operator = "oCLC", period = 2006),
                     list(operator = "oGFC", period = c(2005:2007)))

This modularity is one of the strong sides of `rasterTools`. It allows the user to write their own operator to be used in the respective core-function. An example would be a dataset that is not yet supported by `rasterTools`, to utilize a modification which is not yet included in this package or to develop new landscape metrics. All of this can easily and seamlessly be combined with the previously defined operators in the same, simple work-flow.

## Generate spatial patterns
To build a neutral landscape model, or possibly other spatial data patterns which are based on some sort of simulated process (and are therefore not neutral but perhaps 'virtual'), an algorithm may be:

    anNLM <- list(list(operator = "bHeightmap", fracdim = 2.3))
    
and it would be called by:

    myNLM <- generate(build = myNLM, dimensions = c(400, 500))

The so created spatial dataset can either be utilized directly or could be put through a pipeline of modification algorithms (see below).

## Obtain spatial datasets
An algorithm with which one would obtain information from various spatial data sets could be:

    myDatasets <- list(list(operator = "oCLC", period = 2006),
                       list(operator = "oGFC", period = c(2005:2007)),
                       list(operator = "oMODIS", product = "mod17a3", period = 2006,
                            layer = 2))

Most of the different spatial datasets are available in a specific file format or may have other specific properties, which require consideration. For instance, MODIS data are stored as products with several layers within each file. Consequently the `product` and `layer` need to be specified. Each of the required arguments can be found in the respective documentation, for instance with `?oMODIS`.

This collection of datasets can be obtained by:

    myData <- obtain(data = myDatasets, mask = anyMask)

## Modify gridded objects
A typical modification algorithm determines patches of the foreground in a raster with continuous integer values:

    get_patches <- list(list(operator = "rBinarise", thresh = 30),
                        list(operator = "rPatches"))

When using this algorithm in `modify()` while `sequential = TRUE` the binarised raster will be used to derive patches. The output of `rBinarise` will be passed to `rPatches`, which determines patches from the thresholded rasters values.

However, if you want to determine patches, but also derive categories from the original raster, you have to give each function in the algorithm a specific name. Functions which should be part of the same sub-algorithm have to have the same name:

    cc_cats <- list(get_patches = list(operator = "rBinarise", thresh = 30),
                    get_patches = list(operator = "rPatches"),
                    get_categories = list(operator = "rCategorise", n = 5))

In this case `sequential = TRUE` would be ignored globally, but applied locally for those functions that share the same name (also if it would be set to `FALSE` in the call).

The modifications would be carried out by:

    myModifiedData <- modify(input = myData$gfc, by = get_patches, sequential = TRUE)

## Measure gridded objects
Landscape metrics are another case of algorithms in `rasterTools`. We distinguish between _generic_ and _derived_ landscape metrics. A generic metric typically consists of just one function with its respective arguments:

    patches_area <- list(operator = "mArea", scale = "patch")

A derived metric is any combination of generic and derived metrics. Each metric to be combined in a derived metric needs to be assigned to a specific name that would be referred to in a final element, called `equation`:

    mPropArea <- list(a_w = list(operator = "mArea", scale = "window"),
                      a_c = list(operator = "mArea", scale = "class"),
                      equation = "a_c / a_w * 100")

The most important generic metrics are already predefined and so are some of the derived metrics. By combining all of those and by applying the respective mathematical formulae all other known landscape metrics can be reproduced. It becomes apparent that also new, possibly improved landscapes metrics can be easily prototyped and tested in this framework.

The measurement of the features in a raster would be carried out by:

    propAreaForest <- measure(input = myModifiedData, with = mPropArea)


# Acknowledgements
I am grateful for financial support from the PROFOUND Cost-action, which gave me the opportunity to work in a concentrated effort a large part of the functionality. This package has been developed in support of the [FunBo Project](https://www.researchgate.net/project/Do-small-mammals-think-big-The-multiscale-ecology-of-small-mammals-and-their-functional-role-for-Borrelia-burgdorferi-FunBo), which was made possible by the GrÃ¼newald-Zuberbier Scholarship handed out by the University of Freiburg.

Thanks are also due to Prof. Arne Pommerening who was a great source of inspiration for what `rasterTools` is now.

Moreover, I owe thanks to people like Alex Zvoleff ([`gfcanalysis`](http://azvoleff.com/gfcanalysis)) and Jon Clayden ([`mmand`](https://github.com/jonclayden/mmand)), who inspired me with their uncompromising and creative code-work.

# References