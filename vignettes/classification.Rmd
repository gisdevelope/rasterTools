---
title: "Classify values"
author: "Steffen Ehrmann"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
  rmarkdown::html_document:
    toc: true
    toc_float: true
    theme: spacelab
link-citations: yes
vignette: >
  %\VignetteIndexEntry{Classify values}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(rasterTools)
library(raster)
library(magrittr)
continuous <- rtData$continuous
categorial <- rtData$categorial
catPatchesObj <- rSubstitute(obj = categorial, 
                             old = sort(base::unique(raster::values(categorial))),
                             new = c(1, 2, 3, 4, 3, 4, 5, 5, 5))
binarised <- rBinarise(categorial, match = c(41, 44, 47))
```

This document outlines basic operations that either stand on their own or may be necessary as basis for other operations. If you did not come from the page [Usecases](/rastertools/articles/usecases.html), you should go there now to read in the required objects.

# Classify a raster based on colour values (*cf* HistMapR)
The [HistMapR](https://doi.org/10.1111/2041-210X.12788) package can be used to digitise historic land-use maps in R, according to the authors. However, what their package actually does, in contrast to what is stated in the title, is *(re)classifying* values that are expressed as colour on a screen into numeric values that represent land use classes. The *digitising* part comes already long before, when the orthophotos are transformed from paper to digital form, but this is unfortunately not touched on in that package.

Here I want to suggest a simpler and more straightforward to understand workflow that can be carried out with the `rasterTools` package. Generally speaking, one would carry out a supervised classification procedure on an orthophoto that has previously been made available digitally. As already outlined, the basic idea is to identify (colour) values in the original raster to assign them, after determining sensible thresholds, into new classes. Using `rasterTools`, these operations can be carried out by utilizing mostly the `locate()` and `rCategorise()` functions.

Some background: The `visualise()` function can be used to plot different kinds of objects. Gridded objects are always based on a matrix/array of values. However, the information that is carried by the values differs between datasets. One could consider an image/photo as part of the dataset *"spectral properties of stuff"* as each image records the red, green and blue radiation that is emitted by "stuff". Orthophotos are not different, they also consist of a red, green and blue channel. These channels carry actually the intensity of that colour per pixel, which ranges from 0 to 255. They are typically combined and gain their "colour" qualia only because they are combined. When `visualise()` is used to plot an image, it abstracts the colour information (of potentially > 1.000.000 colours) into a smaller set of values, 256 to be precise. This process already comprises an act of classifying because a range of (admittedly very similar) colours are aggregated into one colour. This is no problem, because let's be honest, you probably can't even remotely distinguish 200 different colours from a give colour scale! Nevertheless, what happens here - and actually also with other functions that plot stuff in R, for that matter - is that the original colours of your map were assigned into 256 classes of similar colours. What we now want to do is distinguish these colours into a substantially smaller set of actual land use classes.

If you did not install the HistMapR package yet, do that now:

```{r}
# devtools::install_github("AGAuffret/HistMapR")
# library(HistMapR)
# data(HistMapRex)
```

We use the example dataset that comes with the package (`in.ras`).

```{r, out.width='100%'}
# visualise(gridded = in.ras, image = TRUE)
```