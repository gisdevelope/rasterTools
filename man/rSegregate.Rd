% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modify.operators.R
\name{rSegregate}
\alias{rSegregate}
\title{Segregate values in a raster into layers}
\usage{
rSegregate(obj, by = NULL, flatten = FALSE, background = NULL)
}
\arguments{
\item{obj}{[\code{RasterLayer(1)}]\cr The object to modify.}

\item{by}{[\code{RasterLayer(1)} | \code{matrix(1)}]\cr additional object by
which \code{obj} should be segregated. If left empty, the distinct values
of \code{obj} will be taken.}

\item{flatten}{[\code{logical(1)}]\cr should all values be set to value 1
(\code{TRUE}) or should the original \code{obj} values be retained
(\code{FALSE}, default)?}

\item{background}{[\code{integerish(1)}]\cr the value any cell with value NA
should have.}
}
\value{
a \code{RasterLayer} stack of the same dimensions as \code{obj}, in
  which the elements specified in \code{by} or the distinct values of
  \code{obj} have each been assigned to a layer of the raster stack.
}
\description{
Distinct values in a raster will be assigned to layers in a raster stack.
}
\examples{
input <- rtData$continuous
patches <- rPatches(rBinarise(input, thresh = 30), background = 0)
myPatches <- rSegregate(patches)
visualise(myPatches[[c(2, 3, 12, 16)]])

# when flattening, all values are set to 1
myPatches2 <- rSegregate(patches, flatten = TRUE)
visualise(myPatches2[[c(2, 3, 12, 16)]])

# cut out by 'patches'
patchValues <- rSegregate(input, by = patches)
visualise(patchValues[[c(2, 3, 12, 16)]])
}
\seealso{
Other operators to modify a raster: \code{\link{rBlend}},
  \code{\link{rReduce}}, \code{\link{rRescale}}
}
