% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/measure.R
\name{measure}
\alias{measure}
\title{Measure gridded objects}
\usage{
measure(input, with, simplify = TRUE)
}
\arguments{
\item{input}{[\code{RasterLayer(1)} | \code{list(.)} thereof]\cr an object or
a named list of objects, which should be measured. Typically retrieved via
\code{\link{obtain}}, and potentially processed with \code{\link{modify}},
but can also be assembled "by hand".}

\item{with}{[\code{character(.)}]\cr algorithm in which the operators
(landscape metrics) to measure spatial patterns are specified. Each
\code{operator} is a list iteself and includes the operator name and its
arguments as sub-elements; see Examples.}

\item{simplify}{[\code{logical(1)}]\cr should only the scale of the first
term and the result be returned (\code{TRUE}, default), or should the the
result of all terms be returned \code{FALSE}?}
}
\value{
depending on the employed metric, but typically a \code{data.frame}.
}
\description{
\code{measure} calls the operators of an algorithm to measure spatial
patterns.
}
\details{
Landscape metrics typically quantify spatial patterns of 2D lattices, such as
maps of landscapes, artificial (spatial) patterns or even photographs. See
\code{vignette("landscape_metrics", package = "rasterTools")} for details on
how landscape metrics are treated in \code{rasterTools}.

A landscape metric can be generic or derived. In the first case the
  metric is a list that includes the \code{operator} name and its arguments.
  In the latter case the metric is a named list of generic metrics (socalled
  terms) and an equation, which determines the term's relationship.

  The following operators for generic metrics are defined: \itemize{ \item
  \code{\link{mAdjacency}}: Determine the adjacency matrix of a raster. \item
  \code{\link{mArea}}: Calculate the area of objects in a raster. \item
  \code{\link{mNumber}}: Count the number of objects in a raster. \item
  \code{\link{mPerimeter}}: Calculate the length of the boundary of objects
  in a raster. \item \code{mValues}: Summarise the values of objects
  in a raster. }
}
\examples{
input <- rtData$categorial

# calculate generic metrics 'area per class' and 'area per window', 'obj' does
# not need to be specified per operator in the algorithm, as 'measure' assigns it.
mAc <- list(operator = "mArea", scale = "class")
mAw <- list(operator = "mArea", scale = "window")
(measure(input = input, with = c("mAc", "mAw")))

# calculate derived metrics 'largest patch index' and
# 'class proportional area'
visualise(input)
(measure(input = input, with = c("mLPI", "mCPA"), simplify = FALSE))

# when a categorial raster is the basis to derive patches, there may be a
# number of patches that may in fact not be distinct patches, so one has to
# be carefull in interpreting these results. Instead, consider:
substituted <- rSubstitute(input, old = c(41:47), new = 40)
visualise(substituted)
(measure(input = substituted, with = c("mLPI", "mCPA")))


# set of spatial operations that enables more complex metrics
# derive 'Disjunct Cores Density', which is a rather complex metric
}
