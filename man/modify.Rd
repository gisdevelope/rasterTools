% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modify.R
\name{modify}
\alias{modify}
\title{Modify gridded objects}
\usage{
modify(input = NULL, by = NULL, sequential = FALSE, merge = FALSE,
  keepInput = FALSE, envir = .GlobalEnv)
}
\arguments{
\item{input}{[\code{RasterLayer(1)} | \code{list(.)} thereof]\cr an object or
a named list of objects, which should be modified. Typically retrieved via
\code{\link{obtain}}, but can also be assembled "by hand".}

\item{by}{[\code{list(.)}]\cr list of \code{operators}, in which the raster
modification functions are specified. Each \code{operator} is a list
iteself and includes the operator name and its arguments as sub-elements;
see Examples.}

\item{sequential}{[\code{lgical(1)}]\cr should the defined operators be
carried out based on the output of the previous operator (\code{TRUE}), or
separately based on the original input (\code{FALSE}, default); see
Details.}

\item{merge}{[\code{logical(1)}]\cr should the resulting object be merged to
a raster stack (\code{TRUE}), or should it remain a list (\code{FALSE},
default).}

\item{keepInput}{[\code{logical(1)}]\cr should \code{input} be retained
(\code{TRUE}) or should it be discarded (\code{FALSE}, default)?}

\item{envir}{[\code{environment}]\cr environment, to which the output of this function should be
saved.}
}
\value{
A list of \code{RasterLayer}s or a \code{RasterStack} of modified
  objects according to the number of chosen datasets and (combinations of)
  operators.
}
\description{
Typical GIS operations modify gridded objects according to a given process.
This can serve to identify certain objects or to prepare the quantitative
assessment of the spatial object in question.
}
\details{
Operators can be called several successive times with modified
  arguments. The following operators are recently defined...

  ... to select a subset of cells: \itemize{ \item \code{\link{rBounded}}:
  Select cells with values between an upper and lower threshold in a raster.
  \item \code{\link{rGreater}}: Select cells with values below a threshold in
  a raster. \item \code{\link{rLess}}: Select cells with values above a
  threshold in a raster. \item \code{\link{rMask}}: Select cells of a raster
  based on a mask. \item \code{\link{rMatch}}: Match cells of a raster with a
  kernel. }

  ... to modify cell values: \itemize{ \item \code{\link{rBinarise}}:
  Binarise the values in a raster. \item \code{\link{rCategorise}}: Assign
  categories to the values in a raster. \item \code{\link{rDistance}}:
  Calculate the distance map for a raster. \item \code{\link{rFillNA}}: Fill
  NA values in a raster. \item \code{\link{rOffset}}: Offset the values in a
  raster. \item \code{\link{rPermute}}: Assign a permutation to the cell
  values of a raster. \item \code{\link{rRange}}: Change the scale of the
  values in a raster. \item \code{\link{rSubstitute}}: Substitute values in a
  raster. }

  ... to determine objects: \itemize{ \item \code{\link{rCentroid}}:
  Determine the centroid of foreground patches in a raster. \item
  \code{\link{rPatches}}: Determine foreground patches in a raster. \item
  \code{\link{rSkeletonise}}: Determine the skeleton of foreground patches in
  a raster. }

  ... to morphologically modify a raster: \itemize{ \item
  \code{\link{rDilate}}: Morphologically dilate foreground patches in a
  raster. \item \code{\link{rErode}}: Morphologically erode foreground
  patches in a raster. }

  ... to modify the overall raster: \itemize{ \item \code{\link{rBlend}}:
  Blend two rasters with each other. \item \code{\link{rReduce}}: Combine a
  raster stack after segregation. \item \code{\link{rRescale}}: Rescale a
  raster. \item \code{\link{rSegregate}}: Segregate values in a raster into
  layers. }

  Moreover, you can create your own operator or check this package's
  \href{https://github.com/EhrmannS/rastertools}{github} page to suggest new
  algorithms or make a pull-request.
}
\examples{
input <- rtData$continuous

# employ modification with merely one operator
binarised <- rBinarise(input, thresh = 40)
visualise(binarised)

# employ several operators combined to an algorithm, 'obj' does not need to
# be specified per operator in the algorithm, as 'modify' assigns it.
getPatches <- list(list(operator = "rBinarise", thresh = 40),
                   list(operator = "rPatches"))
patches <- modify(input, by = getPatches, sequential = TRUE)
visualise(patches)

# To run separated sub-algorithms, use names for each operator to specify
# which elements should be computed sequentially.
getPatchNCats <- list(get_patches = list(operator = "rBinarise", thresh = 40),
                      get_patches = list(operator = "rPatches"),
                      get_categories = list(operator = "rCategorise", n = 5))
patchNCats <- modify(input, by = getPatchNCats, merge = TRUE)
visualise(patchNCats)

# Create objects that are usable later in the algorithm
getMedialAxis <- list(skeleton = list(operator = "rSkeletonise", background = 0),
                      medAxis = list(operator = "rPermute"),
                      medAxis = list(operator = "rDistance"),
                      medAxis = list(operator = "rMask", mask = "skeleton"))
MAT <- modify(binarised, by = getMedialAxis, merge = TRUE)
visualise(MAT, trace = TRUE)
}
